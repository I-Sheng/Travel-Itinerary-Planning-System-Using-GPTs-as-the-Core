# -*- coding: utf-8 -*-
"""Copy of SVM_food.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dY_VdjI4T4t74l7OHydynbglhpUlcx5v
"""



from sklearn.svm import SVR
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.metrics import mean_squared_error
from sklearn.multioutput import MultiOutputRegressor
import json

def getTrainDataList():
    populartimes :list = []
    timeSpentList: list = []
    with open('popular_timeSpent.json', 'r') as file:
        json_data = file.read()
        data = json.loads(json_data)
        for record in data:
            populartimeList = [record['populartimes'][i]['data'] for i in range(7)]
            populartime = []
            for i in range(len(populartimeList)):
              if sum(populartimeList[i]) == 0:
                continue
              populartimes.append(populartimeList[i])
              timelist = record['time_spent']
              timeSpentList.append(timelist)
    return populartimes, timeSpentList

def getUnseenDataList():
    populartimes :list = []
    with open('popular_notimeSpent.json', 'r') as file:
        json_data = file.read()
        data = json.loads(json_data)
        for record in data:
            populartimeList = [record['populartimes'][i]['data'] for i in range(7)]
            populartime = []
            for i in range(len(populartimeList)):
                populartime += populartimeList[i]
            populartimes.append(populartime)
    return populartimes

def q_error(test, answer):
    try:
        if len(test) != len(answer):
            raise ValueError("the length of the test and answer is not equal")
    except ValueError as e:
        print(e)

    error = 0
    for i in range(len(test)):
        error += abs(test[i] - answer[i]) / answer[i]

    error /= len(test)
    return error

X, y = getTrainDataList()
print(f"len(X): {len(X)}")
print(f"len(y): {len(y)}")

print(f"X[0]: {X[0]}")
print(f"len(X[0]): {len(X[0])}")
print(f"y[0]: {y[0]}")
print(f"len(y[0]): {len(y[0])}")

# Define the parameter grid with the correct prefix
parameters = {
    'estimator__kernel': ['poly'],
    'estimator__C': [0.01, 0.1, 1, 10, 100],
    'estimator__gamma': [0.001, 0.01, 0.1, 1],  # gamma parameter values
    'estimator__degree': [3, 4]  # This will only apply if the kernel is 'poly'
}

svr = SVR()

model = MultiOutputRegressor(svr)


clf = GridSearchCV(model, parameters, cv=5)  # cv=5 for 5-fold cross-validation
clf.fit(X, y)
print(sorted(clf.cv_results_.keys()))



best_model = clf.best_estimator_
print("Best model:", best_model)

# Retrieve and print the best model parameters
best_params = clf.best_params_
print("Best parameters:", best_params)

best_kernel, best_C, best_gamma, best_degree =  clf.best_params_['estimator__kernel'], clf.best_params_['estimator__C'], clf.best_params_['estimator__gamma'], clf.best_params_['estimator__degree']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
svr = SVR(kernel=best_kernel, C=best_C, gamma=best_gamma, degree=best_degree)
model = MultiOutputRegressor(svr)
model.fit(X_train, y_train)

def compare_answer(train, predictions, test):
  try:
    if len(predictions) != len(test):
        raise ValueError("the length of the predictions and test is not equal")
  except ValueError as e:
    print(e)

  first_error = q_error([i[0] for i in predictions], [i[0] for i in test])
  second_error = q_error([i[1] for i in predictions], [i[1] for i in test])
  print(f"first q_error: {first_error:.3f}")
  print(f"second q_error: {second_error:.3f}")

  for i in range(len(test)):
    print("input: ", train[i])
    less, most = predictions[i]
    print(f"prediction:  [{less:.3f}, {most:.3f}]")
    print("true answer", test[i])

test_predictions = model.predict(X_test)
compare_answer(X_test, test_predictions, y_test)

#test_predictions

train_predictions = model.predict(X_train)
compare_answer(X_train, train_predictions, y_train)

#train_predictions

def predict_sites(data:list):
  dayCount: int = 0
  dayList: list = []
  for i in range(0,168,24):
    if sum(data[i:i+24]) == 0:
      continue
    dayList.append(data[i:i+24])
    dayCount += 1

  dayPredictions = model.predict(dayList)
  #return sum(dayPredictions) / len(dayPredictions)
  return [sum([i[0] for i in dayPredictions]) / len(dayPredictions), sum([i[1] for i in dayPredictions]) / len(dayPredictions)]
  # Two line above is the same

unseen_data = getUnseenDataList()

unseen_prediction :list = []

for data in unseen_data:
  unseen_prediction.append(predict_sites(data))

try:
  if len(unseen_prediction) != len(unseen_data):
      raise ValueError("the length of predictions is wrong")
  print("The length of predictions is correct")
except ValueError as e:
  print(e)

for predict in unseen_prediction:
  less, most = predict
  print(f"({less:.3f}, {most:.3f})")